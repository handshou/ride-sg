# Cursor Rules for Ride-SG Project

## Package Manager
- This project uses **pnpm** instead of npm
- Always use `pnpm run` commands instead of `npm run`
- Use `pnpm install` for dependency management
- Use `pnpm add` for adding new dependencies

## Automatic Build & Lint Checking
- Always run `pnpm run lint` after making changes
- Always run `pnpm run build` to check for TypeScript errors
- Check for linter errors using `read_lints` tool before completing tasks
- Fix any TypeScript compilation errors immediately
- Use `pnpm run check-all` for comprehensive checking

## Project-Specific Rules
- Use Effect-TS patterns consistently
- Follow the established service layer pattern
- Use proper error handling with Effect.catchAll
- Maintain type safety throughout
- Use Context.GenericTag for service dependencies
- Use Layer.succeed for service implementations

## MCP (Model Context Protocol) Integration
- **Effect MCP**: Use `mcp_effect-docs_effect_docs_search` and `mcp_effect-docs_get_effect_doc` for Effect-TS documentation
- **Mapbox MCP**: Use Mapbox MCP tools for geocoding and mapping:
  - `mcp_MapboxServer_ForwardGeocodeTool` for address → coordinates
  - `mcp_MapboxServer_ReverseGeocodeTool` for coordinates → address
  - `mcp_MapboxServer_StaticMapImageTool` for static map generation
  - `mcp_MapboxServer_DirectionsTool` for routing
  - `mcp_MapboxServer_IsochroneTool` for travel time analysis
- Always test MCP tools before implementing in services
- Use synchronous Effect patterns for server components (Effect.sync, not Effect.tryPromise)

## Code Quality Standards
- No TypeScript errors allowed
- No linting errors allowed
- All imports must be properly typed
- All Effect programs must have proper error handling
- All services must follow the established patterns
- Use proper import organization (alphabetical order)

## Build Process
1. Check for linting errors with `read_lints`
2. Run `pnpm run type-check` for TypeScript compilation
3. Run `pnpm run build` to verify Next.js build
4. Fix any issues before marking tasks as complete
5. Ensure all Effect-TS patterns are properly implemented

## Server Component Rules
- Use synchronous Effects only (Effect.sync, Effect.succeed)
- **Effect.sync**: For side-effectful computations that won't fail (logging, DOM manipulation)
- **Effect.succeed**: For pure values without side effects or dependencies
- Avoid async Effects in server components (no Effect.tryPromise)
- Use Next.js Image component instead of HTML img tags
- No event handlers in server components (onError, onClick, etc.)
- Use proper error handling with Effect.catchAll
- Configure external image domains in next.config.ts for remote images

## Error Handling
- Always use Effect.catchAll for error recovery
- Provide meaningful error messages
- Handle Effect failures gracefully
- Use proper service layer error handling
- Return fallback values for critical operations

## File Organization
- Keep services in `src/lib/` directory
- Use consistent naming: `ServiceName` for interfaces, `ServiceNameImpl` for implementations
- Export service layers as `ServiceNameLive`
- Use proper TypeScript type imports with `type` keyword

## Naming Conventions

### Files and Directories
- Use kebab-case for directories: `user-profile/`
- Use camelCase for files: `userService.ts`
- Use PascalCase for React components: `UserProfile.tsx`
- Use camelCase for Effect services: `loggerService.ts`

### Variables and Functions
- Use camelCase for variables and functions
- Use PascalCase for classes and interfaces
- Use SCREAMING_SNAKE_CASE for constants
- Use descriptive names that explain intent

### Effect-TS Specific
- Suffix Effect functions with `Effect`: `createUserEffect()`
- Use `Service` suffix for service classes: `LoggerService`
- Use `Tag` suffix for context tags: `LoggerServiceTag`
- Use `Live` suffix for layer implementations: `LoggerServiceLive`

## Environment Variables
- Copy `.env.example` to `.env.local` for local development
- Set `MAPBOX_ACCESS_TOKEN` in your environment variables
- Get Mapbox token from: https://account.mapbox.com/access-tokens/
- Use `process.env.MAPBOX_ACCESS_TOKEN` in services
- Never commit `.env*` files (except `.env.example`)

## Testing Standards

### Test File Naming and Locality
- Use `*.spec.ts` naming convention for all test files
- Co-locate test files with their implementations:
  - `src/lib/server-runtime.ts` ↔️ `src/lib/server-runtime.spec.ts`
  - `src/lib/toast-service.ts` ↔️ `src/lib/toast-service.spec.ts`
  - `src/lib/mapbox-service.ts` ↔️ `src/lib/mapbox-service.spec.ts`
- Place e2e tests in `tests/e2e/` directory with `*.spec.ts` naming
- Use `tests/e2e/` for Playwright tests, not `src/app/`

### Test Types
- **Unit Tests**: Test individual functions and services (Vitest)
- **E2E Tests**: Test real user interactions and browser behavior (Playwright)
- **Integration Tests**: Test service interactions and error scenarios

### Test Organization
- Keep tests focused on live functionality only
- Avoid excessive mocking and stubbing
- Test real error scenarios in e2e tests, not unit tests
- Use `describe()` blocks to group related tests
- Use descriptive test names that explain the expected behavior

### Test Scripts
- `pnpm run test` - Run unit tests (Vitest)
- `pnpm run test:e2e` - Run e2e tests (Playwright)
- `pnpm run test:e2e:ui` - Run e2e tests with UI
- `pnpm run test:e2e:headed` - Run e2e tests in headed mode

## Commit Messages
- Use concise, descriptive commit messages
- Keep commit suggestions under 50 characters when possible
- Use imperative mood (e.g., "Add feature" not "Added feature")
- Focus on what changed, not why
- Use conventional commit format: `type(scope): description`